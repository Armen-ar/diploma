"""
Часть 1
=======

В консоли Python командой
'pip install poetry' устанавливаем менеджер пакетов (по управлению зависимостями),
'poetry init' задать свой конфиг, предложит название проекта
например 'amazing_hunting' Enter, версия Enter, описание Enter, автор Enter, лицензия Enter, версия
питона Enter. Дальше предлагает интерактивно устанавливать зависимости - отказываемся 'no' и описание
зависимости тоже 'no'  и подтверждаем генерацию 'yes'
Теперь в консоли вместо команды 'pip ....' будет команда 'poetry add ...'
'poetry add django' устанавливаем django и теперь можем от имени админа команды давать
'django-admin startproject amazing_hunting' создаётся папка с файлами и файл db.sqlite3 (БД)
'python ./manage.py runserver' запускаем приложение и видим вэб страницу в режиме Debug (в режиме разработчика).
'Ctrl C' останавливаем приложение и добавляем первый app (приложение в приложении)
'python ./manage.py startapp vacancies' создаём app. Создаётся  в app (папка vacancies), в которой папка migration,
файл admin.py (файл, который настраивает панель администратора), apps.py (настройки app, пока не трогаем),
models.py (модели), test.py (тесты), views.py (вьюшки - контроллеры в MBC формате)
Теперь пишем первую вьюшку в файле views.py в app (папке vacancies):
В файле views.py дописываем функцию 'def hello(request)'.
Это простая функция,которая принимает аргумент (данные от пользователя), но нужно объявить путь - эту вьюшку
связать с путём, по которому она будет вызываться. Для этого используется файл urls.py папки amazing_hunting и
дописываем путь 'path('hello/', views.hello)' и откуда взять функцию (импортируем функцию hello[без скобок] из
файла views) Теперь django приложению сказать, что есть внутри  app (папка vacancies) и что на него вообще нужно
обращать внимание. Это делается в файле settings.py находим константу INSTALLED_APPS (там лежат имена всех приложений,
которые есть в нашем приложении):
'django.contrib.admin' - админ панель
'django.contrib.auth' - система аутентификации и авторизации в django
'django.contrib.contenttypes' - движок для работы с моделями, т.е. работать с БД
'django.contrib.sessions' - для работы с пользователем по аутентификации и авторизации
'django.contrib.messages' - пакет всплывающих сообщений
'django.contrib.staticfiles' - для работы со статикой (js, css, картинки, ...)
И туда добавим наше приложение:
'vacancies',
И можем запускать приложение.
Через верхнее всплывающее окно заходим в 'Edit Configurations', здесь можно поменять порт, хост (не надо пока)
и нажимаем 'Apply' и 'OK' и запускаем сервер
В пути задём 'http://127.0.0.1:8000/hello/' и получаем 'Hello world', что и в функции было прописано.
Создание моделей:
Для работы с БД в django собственная встроенная ОРМ, похожа на alchemy.
Все модели в django должны наследоваться от models.Model, поля являются как экземпляры класса Тип и суффикс Field()
(IntegerField()) и все поля с ограничениями.
Заходим в models.py в app (папки vacancies) и создаём класс (class Vacancies(models.Model))
с полем text = models.CharField(max_length=2000), ограничения 2000 символов.
Для того, чтоб модель переложить в БД нужно создать миграции. Миграция фиксирует состояние БД. Правило: любое
изменение в БД это новая миграция. (Миграция это commit в БД)
В терминале командой 'python ./manage.py makemigrations' делаем миграцию по модели Vacancies. В папке migrations
появляется файл '0001_initial.py' первая миграция - initial. В файле есть класс:
initial = True он первый
dependencies = [] нет зависимостей
операция создания полей (id в виде большого числа и это первичный ключ)
и теперь применим на БД (накатить миграцию) командой 'python ./manage.py migrate'
Создаём вью, которое будет выводить все вакансии из БД
В файле views.py дописываем функцию 'def vacancies(request)'.
и добавим эту вьюшку в файле urls.py в папке amazing_hunting задаём путь.
В таблице vacancies_vacancy записываем текст и после обновления страницы увидим эту запись.
Для того, чтоб обрабатывать куски, пути и которые могут быть параметрами (например id записи)
в django есть path-аргументы(пути) и пишутся они: тип:название параметра (/<int:post_id>/)
Запишем вьюшку с path-аргументом:
В файле views.py дописываем функцию 'def get(request, vacancy_id)'.
в файле urls.py в папке amazing_hunting задаём путь.
Поиск производится по query параметрам. Добавим во вьюшке index параметр поиска.

Часть 2
=======

Для защиты от мошеннических действий на сайте, запросы для метода POST будут отправлены с токеном:
в views.py в методе index должны с запросом вместе сделаем обработку поста - elif: и пишем условие.
Что бы класс принимал аргумент request у вью, как у класс класса вью реализовать метод as_view, который
возвращает функцию, принимающую первым аргументом request. В место 'def index(request):' будет
'class VacancyView(View):'
Для вывода по id (метод для карточки) переходим на классы с помощью специализированных классов. В место
'def get(request, vacancy_id):):' будет 'class VacansyDetailView(DetailView):'
И в файле urls.py папки amazing_hunting нужно переписать пути в место 'path('vacancy/', views.index)' будет
'path('vacancy/', views.VacancyView.as_view())' и в место 'path('vacancy/<int:vacancy_id>/', views.get),'
будет 'path('vacancy/<pk>/', views.VacansyDetailView.as_view()),'

Добавление типов в модели:
-------------------------
после того, как добавили поля, нужно создать миграцию(записать в БД, накатить) в терминале PyCharm
'python ./manage.py makemigrations' и 'python ./manage.py migrate', после того как удаляем из папки
vacancies/migrations файл '0001_initial.py', таблицу vacancies_vacancy из БД и из таблицы django_migrations строчку,
где прописана информация об этой таблице.

Создание админки и отображение в ней модель с вакансиями:
----------------
Админка это UI над БД, достаточно простая: в ней можно создавать записи, удалять, редактировать в БД.
Заходим в файл admin.py в папке vacancies, там уже импортирован модуль admin и у него вызываем атрибут
site и функцию register, в котором передадим модель вакансия. После этого нужен пользователь, который
может зайти в эту админку. Для этого через терминал PyCharm по команде
'python ./manage.py createsuperuser' оставляем по умолчанию 'armen', Email можно пропустить и пароль 12345 и
соглашаемся 'y'. Суперпользователь создан.
В браузере по адресу http://127.0.0.1:8000/admin попадаем на страницу для авторизации, пароль и пользователь
вводим и попадаем на админ панель.
Для того, чтоб отображать на админ панели ...... создаём str метод в файле models.py папки vacancies


Валидаторы, тесты
=================

Валидация модели
----------------

Для проверки данных, которые кладутся в БД в модель с вакансиями добавим поле с минимальным стажем и ограничим
(только для положительных значений). Есть два варианта валидации полей: 1-через атрибуты(максим. длину CharField поля,
поле null, при удалении CASCADE и т.д.); 2-можно совмещать с первым, это специальный атрибут валидатор (массив с
объектами классов валидаторов, которые встроены в Django или написаны нами). Встроенных валидаторов немного: на пустоту,
минимальное максимальное значение и поэтому чаще всего нужны собственные валидаторы. В Django валидаторы пишутся
методами и он должен принимать атрибут value-это то значение, которое пытаемся сохранить в БД, а возвращает либо ничего
если нет ошибок, либо прокидывать или raise-ит нам exception(ValidationError), в котором передаётся текст
отображающийся при ошибке. Добавим поле update_at (дата создания не должно быть меньше чем текущая)

Для проверки данных, которые передаёт пользователь (на уровне сериализатора, когда json превращаем в объекты) проверять,
что json заполнен как нам нужно. И для этого нужно сделать поле slug уникальным в сериализаторе VacancyCreateSerializer.

 Свой валидатор
 --------------

Запретим создавать пользователю закрытую вакансию, она должна быть либо черновиком, либо опубликована. В отличии от
базовой Django в DRF есть два варианта создания валидаторов. 1 - так же как и в Django через функции(функция, которая
принимает атрибут value и возвращает либо ничего если всё хорошо, либо raise-ит ошибку если проверка не пройдена).
Через методы будем использовать, когда мы заранее знаем от чего отталкиваемся(дата отталкиваемся от текущего значения
или значение не должно быть нулём или оно должно быть только чётным и т.д.)
2 - вариант через класс. В классе пишем метод __call__, которая похожа на функцию валидатора. Принимает self, как все
классы, принимает value, что передал пользователь и возвращает либо ничего если всё хорошо, либо raise-ит ошибку если
проверка не пройдена. Отличительная черта это метод __init__ конструктор нашего класса, в который можно передать
дополнительные параметры, сделав валидацию более гибкой. Классы будем использовать тогда, когда сравнивать наши
значения с чем-то ещё (это что-то ещё может быть динамическим - список например). В нашем случае мы будем сравнивать
наш статус со списком других статусов. В сериализаторах


Тесты
=====

В Django принято тестировать, используя библиотеку pytest-django и создать конфигурационный файл pytset.ini в корневой
папке. В нём указываем директиву [pytest] и константу DJANGO_SETTINGS_MODULE, которая указывает на settings.py в папке
amazing_hunting. Создаём папку для тестов tests в корневой папке и в нём создаём файл simple_test.py и в нём запишем
первый тест (метод) test_a и запускаем в консоли pytest.
Делаем тест на '/.' Делаем get запрос на корневой урл, проверяем, что статус 404. В файле simple_test запишем тест.
Для автоматизации(без ввода команд в консоли) тестирования заходим во вкладку 'Edit Configurations' (рядом с
зелёной стрелочкой), в папку Python test и файл pytest и ставим галочку на Custom, прописываем в 'Environment variables'
константу из файла simple_test.py 'DJANGO_SETTINGS_MODULE=amazing_hunting.settings', так же эту константу добавляем во
вкладке 'Django Server' - lesson_27_django(в нашем случае) в 'Environment variables'. Теперь можем запускать тесты
через верхнюю зелёную стрелочку.

Тестировать ручки(роуты), которые требуют похода в БД, тест на список вакансий. Тесты принято делить по логическим
принципам, поэтому для тестирования vacancies создаём соответствующую папку vacancies в папке tests и в неё кладём все
тесты, связанные с вакансиями. В тесте создаём вакансию и сравниваем то, что получили при запросе с тем, что ожидаем.
Для того, чтоб создавая не прописывать в БД, создавать миграции и потом всё это удалить из БД после теста в
pytest-django есть специальный декоратор @pytest.mark.django_db декоратор, который накатит миграции и после окончания
тестирования откатит, но id в postgres присваиваются самостоятельно, поэтому id будет присваивать очередной по
возрастанию.
Если ручка закрыта за авторизацией, например на создание вакансии. Файлы обычно принято делить по вьюшкам.
get отдельный файл, create отдельный файл... Поэтому создаём файл vacancy_create_test.py.
Для того, чтоб все фикстуры читались из одного файла создаётся, т.е. тестам сказать, что нужно заглянуть в фикстуры
делается это через файл conftest.py записываем переменную, которая указывает путь к фикстурам
pytest_plugins = 'tests.fixtures'.
Для того, чтобы работать с моделями очень часто используют фабрики(классы, в которых какие-то значения переопределены,
а все остальные можем динамически менять в самом тесте). Тест на /vacancy/id/ и для начала установим библиотеку
в терминале 'poetry add pytest_factoryboy' или 'pip install' и пишем factory(фабрику) - в отдельном файле factories.py
в папке tests.



Документирование
================
Для этого устанавливаем в консоли пакет командой 'pip install drf-spectacular', после в файле 'settings.py'
подключаем пакет 'drf_spectacular' в 'INSTALLED_APPS' и в 'REST_FRAMEWORK' донастроить и записать
"DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema". Для настройки самой документации в том-же файле после
'REST_FRAMEWORK' создаём новую настройку 'SPECTACULAR_SETTINGS' - название, краткое описание, версия ....
Название - "TITLE": "Hunting API", описание - "DESCRIPTION": "Awesome hunting API", версия - "VERSION": "1.0.0".
Теперь записать урлы, которые всё это будут раздавать. В базовых урлах, папки amazing_hunting файл urls.py допишем
маршрут.

Для отображения в документации описания прописывается декоратор @extend_schema(description="Retrieve vacancy list",
summary="Vacancy list") который переопределяет: краткое описание будет "Vacancy list",
а подробное "Retrieve vacancy list". Для того чтоб избавиться от лишних ручек в документации в самом классе
прописываем все http_method_names методы, которые используем. В классе VacancyLikeView прописываем
http_method_names = ['put']. @extend_schema(deprecated=True)  # помечаем метод устаревшим и говорим, что нужно как
можно быстрее нужно перестать им пользоваться, но параллельно с этим дописывается новый, более модернизированный
метод(замена). В нашем случае нет.
Для документировать сразу весь ViewSet есть специальный декоратор  @extend_schema_view() там прописываем методы,
которые у нам нужны (list, update, delete....) и каждому из них присваиваем description=(подробное описание)
и summary=(краткое описание)
"""
